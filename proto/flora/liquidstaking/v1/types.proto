syntax = "proto3";
package flora.liquidstaking.v1;

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "cosmos/base/v1beta1/coin.proto";

option go_package = "github.com/rollchains/flora/x/liquidstaking/types";

// TokenizationRecord represents a record of staked tokens that have been tokenized
message TokenizationRecord {
  option (gogoproto.goproto_getters) = false;
  
  // id is the unique identifier for this record
  uint64 id = 1;
  
  // validator is the bech32 address of the validator
  string validator = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
  
  // owner is the bech32 address of the record owner
  string owner = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
  
  // shares_tokenized is the amount of shares tokenized
  string shares_tokenized = 4 [
    (cosmos_proto.scalar)  = "cosmos.Int",
    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.nullable)   = false
  ];
  
  // denom is the denomination of the liquid staking token
  string denom = 5;
}

// ModuleParams defines the parameters for the liquid staking module
message ModuleParams {
  option (gogoproto.goproto_getters) = false;
  
  // global_liquid_staking_cap is the global cap for liquid staking as a percentage
  string global_liquid_staking_cap = 1 [
    (cosmos_proto.scalar)  = "cosmos.Dec",
    (gogoproto.customtype) = "cosmossdk.io/math.LegacyDec",
    (gogoproto.nullable)   = false
  ];
  
  // validator_liquid_cap is the per-validator cap for liquid staking as a percentage
  string validator_liquid_cap = 2 [
    (cosmos_proto.scalar)  = "cosmos.Dec",
    (gogoproto.customtype) = "cosmossdk.io/math.LegacyDec",
    (gogoproto.nullable)   = false
  ];
  
  // enabled indicates if the liquid staking module is enabled
  bool enabled = 3;
  
  // min_liquid_stake_amount is the minimum amount required for liquid staking
  string min_liquid_stake_amount = 4 [
    (cosmos_proto.scalar)  = "cosmos.Int",
    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.nullable)   = false
  ];
  
  // rate_limit_period_hours is the time window for rate limiting in hours
  uint32 rate_limit_period_hours = 5;
  
  // global_daily_tokenization_percent is the max percentage of total bonded tokens that can be tokenized globally per day
  string global_daily_tokenization_percent = 6 [
    (cosmos_proto.scalar)  = "cosmos.Dec",
    (gogoproto.customtype) = "cosmossdk.io/math.LegacyDec",
    (gogoproto.nullable)   = false
  ];
  
  // validator_daily_tokenization_percent is the max percentage of validator's tokens that can be tokenized per day
  string validator_daily_tokenization_percent = 7 [
    (cosmos_proto.scalar)  = "cosmos.Dec",
    (gogoproto.customtype) = "cosmossdk.io/math.LegacyDec",
    (gogoproto.nullable)   = false
  ];
  
  // global_daily_tokenization_count is the max number of tokenizations allowed globally per day
  uint64 global_daily_tokenization_count = 8;
  
  // validator_daily_tokenization_count is the max number of tokenizations allowed per validator per day
  uint64 validator_daily_tokenization_count = 9;
  
  // user_daily_tokenization_count is the max number of tokenizations allowed per user per day
  uint64 user_daily_tokenization_count = 10;
  
  // warning_threshold_percent is the percentage of limit at which warning events are emitted
  string warning_threshold_percent = 11 [
    (cosmos_proto.scalar)  = "cosmos.Dec",
    (gogoproto.customtype) = "cosmossdk.io/math.LegacyDec",
    (gogoproto.nullable)   = false
  ];
  
  // auto_compound_enabled indicates if auto-compounding is enabled
  bool auto_compound_enabled = 12;
  
  // auto_compound_frequency_blocks is how often auto-compound runs (in blocks)
  int64 auto_compound_frequency_blocks = 13;
  
  // max_rate_change_per_update is the maximum allowed exchange rate change per update
  string max_rate_change_per_update = 14 [
    (cosmos_proto.scalar)  = "cosmos.Dec",
    (gogoproto.customtype) = "cosmossdk.io/math.LegacyDec",
    (gogoproto.nullable)   = false
  ];
  
  // min_blocks_between_updates is the minimum blocks between exchange rate updates
  int64 min_blocks_between_updates = 15;
}

// ExchangeRate defines the exchange rate for a specific LST token
message ExchangeRate {
  option (gogoproto.goproto_getters) = false;
  
  // validator_address is the bech32 address of the validator
  string validator_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
  
  // denom is the LST denom
  string denom = 2;
  
  // rate is the exchange rate (native tokens per LST token)
  string rate = 3 [
    (cosmos_proto.scalar) = "cosmos.Dec",
    (gogoproto.customtype) = "cosmossdk.io/math.LegacyDec",
    (gogoproto.nullable) = false
  ];
  
  // last_updated is the Unix timestamp of the last update
  int64 last_updated = 4;
}

// GlobalExchangeRate tracks the overall exchange rate statistics
message GlobalExchangeRate {
  option (gogoproto.goproto_getters) = false;
  
  // rate is the global average exchange rate
  string rate = 1 [
    (cosmos_proto.scalar) = "cosmos.Dec",
    (gogoproto.customtype) = "cosmossdk.io/math.LegacyDec",
    (gogoproto.nullable) = false
  ];
  
  // last_updated is the Unix timestamp of the last update
  int64 last_updated = 2;
  
  // total_staked is the total amount of tokens staked
  string total_staked = 3 [
    (cosmos_proto.scalar) = "cosmos.Int",
    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.nullable) = false
  ];
  
  // total_rewards is the total accumulated rewards
  string total_rewards = 4 [
    (cosmos_proto.scalar) = "cosmos.Int",
    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.nullable) = false
  ];
  
  // total_lst_supply is the total supply of all LST tokens
  string total_lst_supply = 5 [
    (cosmos_proto.scalar) = "cosmos.Int",
    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.nullable) = false
  ];
}