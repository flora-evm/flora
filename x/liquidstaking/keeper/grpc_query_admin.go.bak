package keeper

import (
	"context"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/rollchains/flora/x/liquidstaking/types"
)

// EmergencyStatus implements the Query/EmergencyStatus gRPC method
func (k Keeper) EmergencyStatus(c context.Context, req *types.QueryEmergencyStatusRequest) (*types.QueryEmergencyStatusResponse, error) {
	if req == nil {
		return nil, status.Error(codes.InvalidArgument, "invalid request")
	}

	ctx := sdk.UnwrapSDKContext(c)

	// Check if module is paused
	paused := k.IsModulePaused(ctx)
	
	// Get emergency pause info if exists
	pauseInfo, found := k.GetEmergencyPauseInfo(ctx)
	
	response := &types.QueryEmergencyStatusResponse{
		Paused: paused,
	}
	
	if found && paused {
		response.PausedAt = pauseInfo.PausedAt.Unix()
		response.Authority = pauseInfo.Authority
		if !pauseInfo.UnpauseAt.IsZero() {
			response.UnpauseAt = pauseInfo.UnpauseAt.Unix()
		}
	}
	
	return response, nil
}

// ValidatorWhitelist implements the Query/ValidatorWhitelist gRPC method
func (k Keeper) ValidatorWhitelist(c context.Context, req *types.QueryValidatorWhitelistRequest) (*types.QueryValidatorWhitelistResponse, error) {
	if req == nil {
		return nil, status.Error(codes.InvalidArgument, "invalid request")
	}

	ctx := sdk.UnwrapSDKContext(c)

	whitelist := k.GetValidatorWhitelist(ctx)
	
	return &types.QueryValidatorWhitelistResponse{
		Validators: whitelist,
	}, nil
}

// ValidatorBlacklist implements the Query/ValidatorBlacklist gRPC method
func (k Keeper) ValidatorBlacklist(c context.Context, req *types.QueryValidatorBlacklistRequest) (*types.QueryValidatorBlacklistResponse, error) {
	if req == nil {
		return nil, status.Error(codes.InvalidArgument, "invalid request")
	}

	ctx := sdk.UnwrapSDKContext(c)

	blacklist := k.GetValidatorBlacklist(ctx)
	
	return &types.QueryValidatorBlacklistResponse{
		Validators: blacklist,
	}, nil
}

// ValidatorStatus implements the Query/ValidatorStatus gRPC method
func (k Keeper) ValidatorStatus(c context.Context, req *types.QueryValidatorStatusRequest) (*types.QueryValidatorStatusResponse, error) {
	if req == nil {
		return nil, status.Error(codes.InvalidArgument, "invalid request")
	}

	ctx := sdk.UnwrapSDKContext(c)

	// Validate validator address
	valAddr, err := sdk.ValAddressFromBech32(req.ValidatorAddress)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "invalid validator address: %s", err)
	}

	// Check if validator exists
	validator, err := k.stakingKeeper.GetValidator(ctx, valAddr)
	if err != nil {
		return nil, status.Errorf(codes.NotFound, "validator not found: %s", err)
	}

	// Check if allowed
	isAllowed := k.IsValidatorAllowed(ctx, req.ValidatorAddress)
	isBlacklisted := k.IsValidatorBlacklisted(ctx, req.ValidatorAddress)
	isWhitelisted := k.IsValidatorWhitelisted(ctx, req.ValidatorAddress)
	
	// Get custom cap if any
	customCap, hasCustomCap := k.GetValidatorLiquidCap(ctx, req.ValidatorAddress)
	
	// Get current liquid staked amount
	liquidStaked := k.GetValidatorLiquidStakedAmount(ctx, req.ValidatorAddress)
	
	// Calculate percentage
	totalStaked := validator.GetTokens()
	liquidPercent := sdk.ZeroDec()
	if totalStaked.IsPositive() {
		liquidPercent = sdk.NewDecFromInt(liquidStaked).Quo(sdk.NewDecFromInt(totalStaked))
	}
	
	response := &types.QueryValidatorStatusResponse{
		IsAllowed:      isAllowed,
		IsBlacklisted:  isBlacklisted,
		IsWhitelisted:  isWhitelisted,
		LiquidStaked:   liquidStaked.String(),
		LiquidPercent:  liquidPercent.String(),
		TotalStaked:    totalStaked.String(),
	}
	
	if hasCustomCap {
		response.HasCustomCap = true
		response.CustomCap = customCap.String()
	}
	
	return response, nil
}